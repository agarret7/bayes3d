"""Trimesh to Gaussians
> Pretty much self-explanatory

**Example:**
```python
from bayes3d._mkl.trimesh_to_gaussians import (
    patch_trimesh, 
    uniformly_sample_from_mesh, 
    ellipsoid_embedding, 
    get_mean_colors, 
    pack_transform
)
import numpy as np
from sklearn.mixture import GaussianMixture
from jax import vmap

mesh = load_mesh(...)
mesh = patch_trimesh(mesh)

key = keysplit(key)
n = 20_000
xs, cs = uniformly_sample_from_mesh(key, n, mesh, with_color=True)


# GMM config
key = keysplit(key)
n_components = 150
noise        = 0.0; 
X            = xs + np.random.randn(*xs.shape)*noise
means_init   = np.array(uniformly_sample_from_mesh(key, n_components, mesh, with_color=False)[0]);

# Fit the GMM
gm = GaussianMixture(n_components=n_components, 
                     tol=1e-3, max_iter=100, 
                     covariance_type="full", 
                     means_init=means_init).fit(X)

mus       = gm.means_
covs      = gm.covariances_
labels    = gm.predict(X)
choleskys = vmap(ellipsoid_embedding)(covs)
mean_colors, nums = get_mean_colors(cs, gm.n_components, labels)
transforms = vmap(pack_transform, (0,0,None))(mus, choleskys, 2.0)
```
"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../scripts/_mkl/notebooks/05 - Trimesh to Gaussians.ipynb.

# %% auto 0
__all__ = ['Array', 'Shape', 'FaceIndex', 'FaceIndices', 'Array3', 'Array2', 'ArrayNx2', 'ArrayNx3', 'compute_area_and_normals',
           'area_of_triangle', 'patch_trimesh', 'texture_uv_basis', 'uv_to_color', 'barycentric_to_mesh',
           'sample_from_face', 'sample_from_mesh', 'get_colors_from_mesh', 'uniformly_sample_from_mesh',
           'get_cluster_counts', 'get_colors', 'get_mean_colors', 'ellipsoid_embedding', 'pack_transform']

# %% ../../scripts/_mkl/notebooks/05 - Trimesh to Gaussians.ipynb 2
_doc_ = """Trimesh to Gaussians
> Pretty much self-explanatory

**Example:**
```python
from bayes3d._mkl.trimesh_to_gaussians import (
    patch_trimesh, 
    uniformly_sample_from_mesh, 
    ellipsoid_embedding, 
    get_mean_colors, 
    pack_transform
)
import numpy as np
from sklearn.mixture import GaussianMixture
from jax import vmap

mesh = load_mesh(...)
mesh = patch_trimesh(mesh)

key = keysplit(key)
n = 20_000
xs, cs = uniformly_sample_from_mesh(key, n, mesh, with_color=True)


# GMM config
key = keysplit(key)
n_components = 150
noise        = 0.0; 
X            = xs + np.random.randn(*xs.shape)*noise
means_init   = np.array(uniformly_sample_from_mesh(key, n_components, mesh, with_color=False)[0]);

# Fit the GMM
gm = GaussianMixture(n_components=n_components, 
                     tol=1e-3, max_iter=100, 
                     covariance_type="full", 
                     means_init=means_init).fit(X)

mus       = gm.means_
covs      = gm.covariances_
labels    = gm.predict(X)
choleskys = vmap(ellipsoid_embedding)(covs)
mean_colors, nums = get_mean_colors(cs, gm.n_components, labels)
transforms = vmap(pack_transform, (0,0,None))(mus, choleskys, 2.0)
```
"""

# %% ../../scripts/_mkl/notebooks/05 - Trimesh to Gaussians.ipynb 3
import bayes3d as b3d
import trimesh
from bayes3d._mkl.utils import *
import os
import matplotlib.pyplot as plt
import numpy as np
import jax
from jax import jit, vmap
import jax.numpy as jnp

# %% ../../scripts/_mkl/notebooks/05 - Trimesh to Gaussians.ipynb 5
from typing import Any, NamedTuple


Array = np.ndarray | jax.Array
Shape = int | tuple[int, ...]
FaceIndex = int
FaceIndices = Array
Array3      = Array
Array2      = Array
ArrayNx2    = Array
ArrayNx3    = Array

# %% ../../scripts/_mkl/notebooks/05 - Trimesh to Gaussians.ipynb 7
def area_of_triangle(a:Array3, b:Array3, c:Array3=jnp.zeros(3)):

    v = a-c
    w = b-c

    l = jnp.linalg.norm(w)
    h = jnp.linalg.norm(v - jnp.dot(v, w)/l**2*w)
    area = l*h

    return area/2


def _compute_area_and_normal(f:FaceIndex, vertices):
    a = vertices[f[1]] - vertices[f[0]]
    b = vertices[f[2]] - vertices[f[0]]
    area = area_of_triangle(a, b)
    normal = jnp.cross(a,b)
    return area, normal


compute_area_and_normals = jit(vmap(_compute_area_and_normal, (0,None)))

# %% ../../scripts/_mkl/notebooks/05 - Trimesh to Gaussians.ipynb 8
def patch_trimesh(mesh:trimesh.base.Trimesh):
    """
    Return a patched copy of a trimesh object, and 
    ensure it to have a texture and the following attributes:
    - `mesh.visual.uv`
    - `copy.visual.material.to_color`
    """
    patched_mesh = mesh.copy()
    if isinstance(mesh.visual, trimesh.visual.color.ColorVisuals):
        patched_mesh.visual = mesh.visual.to_texture()
    elif isinstance(mesh.visual, trimesh.visual.texture.TextureVisuals):
        pass

    return patched_mesh


def texture_uv_basis(face_idx:Array, mesh):
    return mesh.visual.uv[mesh.faces[face_idx]]


def uv_to_color(uv:ArrayNx2, mesh):
    return mesh.visual.material.to_color(uv)

# %% ../../scripts/_mkl/notebooks/05 - Trimesh to Gaussians.ipynb 9
def barycentric_to_mesh(p:Array3, i:FaceIndex, mesh):
    x = jnp.sum(p[:,None]*mesh.vertices[mesh.faces[i]], axis=0)
    return x


def sample_from_face(key, n, i, mesh):
    _, key = keysplit(key,1,1)
    ps = jax.random.dirichlet(key, jnp.ones(3), (n,)).reshape((n,3,1))
    xs = jnp.sum(ps*mesh.vertices[mesh.faces[i]], axis=1)
    return xs, ps


def sample_from_mesh(key, n, mesh):
    """
    Returns random points `xs`, barycentric coordinates `ps`, and 
    face indices `fs` from a mesh.
    """
    key, keys = keysplit(key,1,2)
    areas, _ = compute_area_and_normals(mesh.faces, mesh.vertices)
    fs = jax.random.categorical(keys[0], jnp.log(areas), shape=(n,))
    ps = jax.random.dirichlet(keys[1], jnp.ones(3), (n,)).reshape((n,3,1))
    xs = jnp.sum(ps*mesh.vertices[mesh.faces[fs]], axis=1)
    return xs, ps, fs
    

def get_colors_from_mesh(ps:ArrayNx3, fs:FaceIndices, mesh):
    uvs = jnp.sum(ps * texture_uv_basis(fs, mesh), axis=1)
    cs  = uv_to_color(uvs, mesh)/255
    return cs

# %% ../../scripts/_mkl/notebooks/05 - Trimesh to Gaussians.ipynb 11
def uniformly_sample_from_mesh(key, n, mesh, with_color=True):
    """Uniformly sample `n` points and optionally their color on the surface from a mesh."""
    key, keys = keysplit(key,1,2)

    xs,ps,fs = sample_from_mesh(key, n, mesh)

    # First sample face indices, then sample barycentric coordinates, and
    # finally compute the positions of the points.
    # fs = jax.random.categorical(keys[0], jnp.log(areas), shape=(n,))
    # ps = jax.random.dirichlet(keys[1], jnp.ones(3), (n,)).reshape((n,3,1))
    # xs = jnp.sum(ps*mesh.vertices[mesh.faces[fs]], axis=1)

    if with_color:
        uvs = jnp.sum(ps* texture_uv_basis(fs, mesh), axis=1)
        cs  = uv_to_color(uvs, mesh)/255
    else:
        cs = jnp.full((n,3), 0.5)

    return xs, cs

# %% ../../scripts/_mkl/notebooks/05 - Trimesh to Gaussians.ipynb 12
def get_cluster_counts(n, labels):
    nums = []
    for label in range(n):
        idx = labels == label
        nums.append(np.sum(idx))
    return np.array(nums)

# %% ../../scripts/_mkl/notebooks/05 - Trimesh to Gaussians.ipynb 13
def get_colors(cs, n, labels):
    colors = []
    nums   = []
    for label in range(n):
        idx = labels == label
        nums.append(np.sum(idx))
        colors.append(cs[idx])
    return colors, np.array(nums)

# %% ../../scripts/_mkl/notebooks/05 - Trimesh to Gaussians.ipynb 14
def get_mean_colors(cs, n, labels):
    mean_colors = []
    nums        = []
    for label in range(n):
        idx = labels == label
        nums.append(np.sum(idx))
        if np.sum(idx) == 0: 
            mean_colors.append(np.array([0.5,0.5,0.5, 0.0]))
        else:                
            mean_colors.append(np.mean(cs[idx], axis=0))
    return np.array(mean_colors), np.array(nums)
    

# %% ../../scripts/_mkl/notebooks/05 - Trimesh to Gaussians.ipynb 15
def ellipsoid_embedding(Cov):
    """Returns A with cov = A@A.T"""
    sigma, U = jnp.linalg.eigh(Cov)
    D = jnp.diag(jnp.sqrt(sigma))
    return U @ D @ jnp.linalg.inv(U)


# %% ../../scripts/_mkl/notebooks/05 - Trimesh to Gaussians.ipynb 16
def pack_transform(x, A, scale=1.0):
    B = scale*A
    return jnp.array([
        [B[0,0], B[0,1], B[0,2], x[0]], 
        [B[1,0], B[1,1], B[1,2], x[1]],
        [B[2,0], B[2,1], B[2,2], x[2]],
        [0.0, 0.0, 0.0, 1.0]
    ]).T
