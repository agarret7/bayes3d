# AUTOGENERATED! DO NOT EDIT! File to edit: ../../scripts/_mkl/notebooks/06a - Gaussian Renderer.ipynb.

# %% auto 0
__all__ = ['normal_cdf', 'normal_pdf', 'normal_logpdf', 'inv', 'key', 'Array', 'Shape', 'FaceIndex', 'FaceIndices', 'ArrayN',
           'Array3', 'Array2', 'ArrayNx2', 'ArrayNx3', 'Matrix', 'PrecisionMatrix', 'CovarianceMatrix', 'SquareMatrix',
           'Vector', 'Direction', 'BaseVector', 'cast_rays', 'bilinear', 'log_gaussian', 'gaussian',
           'ellipsoid_embedding', 'fuzzy_intersection']

# %% ../../scripts/_mkl/notebooks/06a - Gaussian Renderer.ipynb 3
import bayes3d as b3d
import trimesh
import os
from bayes3d._mkl.utils import *
import matplotlib.pyplot as plt
import numpy as np
import jax
from jax import jit, vmap
import jax.numpy as jnp
from functools import partial
from bayes3d.camera import Intrinsics, K_from_intrinsics, camera_rays_from_intrinsics
from bayes3d.transforms_3d import transform_from_pos_target_up, add_homogenous_ones, unproject_depth


normal_cdf    = jax.scipy.stats.norm.cdf
normal_pdf    = jax.scipy.stats.norm.pdf
normal_logpdf = jax.scipy.stats.norm.logpdf
inv = jnp.linalg.inv

key = jax.random.PRNGKey(0)

# %% ../../scripts/_mkl/notebooks/06a - Gaussian Renderer.ipynb 5
from typing import Any, NamedTuple
import jaxlib

Array = np.ndarray | jax.Array
Shape = int | tuple[int, ...]
FaceIndex = int
FaceIndices = Array
ArrayN      = Array
Array3      = Array
Array2      = Array
ArrayNx2    = Array
ArrayNx3    = Array
Matrix      = jaxlib.xla_extension.ArrayImpl
PrecisionMatrix  = Matrix
CovarianceMatrix = Matrix
SquareMatrix     = Matrix
Vector = Array
Direction = Vector
BaseVector = Vector


# %% ../../scripts/_mkl/notebooks/06a - Gaussian Renderer.ipynb 6
def bilinear(x:Array, y:Array, A:SquareMatrix):
    return x.T @ A @ y


def log_gaussian(x, mu, omega:PrecisionMatrix):
    """Evaluate an unnormalized gaussian at a given point."""
    return -0.5 * bilinear(x-mu, x-mu, omega)


def gaussian(x, mu, omega:PrecisionMatrix):
    """Evaluate an unnormalized gaussian at a given point."""
    return jnp.exp(-0.5 * bilinear(x-mu, x-mu, omega))


inv = jnp.linalg.inv

# %% ../../scripts/_mkl/notebooks/06a - Gaussian Renderer.ipynb 8
def ellipsoid_embedding(cov:CovarianceMatrix):
    """Returns A with cov = A@A.T"""
    sigma, U = jnp.linalg.eigh(cov)
    D = jnp.diag(jnp.sqrt(sigma))
    return U @ D @ jnp.linalg.inv(U)

# %% ../../scripts/_mkl/notebooks/06a - Gaussian Renderer.ipynb 12
def fuzzy_intersection(mu:Vector, omega:PrecisionMatrix, x:Vector, v:Direction):
    """
    Returns the "intersection" of a ray with a gaussian which we define as
    the mode of the gaussian restricted to the ray.
    """
    t = bilinear(mu - x, v, omega)/bilinear(v, v, omega)
    return t

# %% ../../scripts/_mkl/notebooks/06a - Gaussian Renderer.ipynb 13
def _cast_ray(v, mus, precisions, colors, weights, zmax=2., bg_color=jnp.array([1.,1.,1.,1.0])):
    # TODO: Deal with negative intersections behind the camera
    # TODO: Maybe switch to log probs?

    # Compute fuzy intersections `xs` with Gaussians and 
    # their function values `sigmas`
    ts     = vmap(fuzzy_intersection, (0,0,None,None))(mus, precisions, jnp.zeros(3), v)
    order  = jnp.argsort(ts)
    ts     = ts[order]
    xs     = ts[:,None]*v[None,:]
    sigmas = weights * vmap(gaussian)(xs, mus[order], precisions[order])

    # TODO: Ensure that alphas are in [0,1]
    # Alternatively we can set 
    # alphas = (1 - jnp.exp(-sigmas*1.0))
    alphas = sigmas * (ts > 0)
    transmittances = jnp.concatenate([jnp.array([1.0]), jnp.cumprod(1-alphas[:-1])])
    ws = alphas*transmittances # Ordered mixture weights

    mean_depth = jnp.sum(ws*xs[:,2])
    mean_color = jnp.sum(ws[:,None]*colors[order], axis=0)
    
    op = jnp.sum(ws) # Opacity
    mean_depth = mean_depth + (1 - op)*zmax
    mean_color = mean_color + (1 - op)*bg_color
    mean_color = mean_color.at[-1].set(op)
    
    return mean_depth, mean_color, op

cast_rays = jit(vmap(_cast_ray, (0,None,None,None,None)))
